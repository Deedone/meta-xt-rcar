From 2cae81cae6412a9006a7eddfd116edecf4d3fe4e Mon Sep 17 00:00:00 2001
Message-Id: <2cae81cae6412a9006a7eddfd116edecf4d3fe4e.1728475681.git.mykyta_poturai@epam.com>
From: Mykyta Poturai <mykyta_poturai@epam.com>
Date: Wed, 9 Oct 2024 15:07:19 +0300
Subject: [PATCH] guest/volcanic: Create and register DMA PhysHeapConfig
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Implemented required functionality according to
“5.8.1. Hypervisor-assisted using dynamic firmware heap allocation”
section of “PowerVR Graphics DDK Services Virtualisation Porting Guide”.
Ported to volcanic.

Signed-off-by: Mykyta Poturai <mykyta_poturai@epam.com>
---
 services/system/volcanic/rgx_rcar/sysconfig.c | 53 +++++++++++++++++--
 1 file changed, 50 insertions(+), 3 deletions(-)

diff --git a/services/system/volcanic/rgx_rcar/sysconfig.c b/services/system/volcanic/rgx_rcar/sysconfig.c
index 84329a1..6c219c3 100644
--- a/services/system/volcanic/rgx_rcar/sysconfig.c
+++ b/services/system/volcanic/rgx_rcar/sysconfig.c
@@ -73,6 +73,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "validation_soc.h"
 #endif
 
+#define PHYS_HEAP_IDX_GENERAL     0
+#define PHYS_HEAP_IDX_FW          1
 typedef struct _SYS_DATA_ SYS_DATA;
 
 struct _SYS_DATA_
@@ -149,8 +151,10 @@ static PHYS_HEAP_FUNCTIONS gsPhysHeapFuncs =
 	xMAPhysHeapDevPAddrToCpuPAddr,
 };
 
+static DMA_ALLOC gsDmaAlloc;
 static PVRSRV_ERROR PhysHeapsCreate(PHYS_HEAP_CONFIG **ppasPhysHeapsOut,
-									IMG_UINT32 *puiPhysHeapCountOut)
+									IMG_UINT32 *puiPhysHeapCountOut,
+									void *pvOSDevice)
 {
 	/*
 	 * This function is called during device initialisation, which on Linux,
@@ -221,7 +225,42 @@ static PVRSRV_ERROR PhysHeapsCreate(PHYS_HEAP_CONFIG **ppasPhysHeapsOut,
 		pasPhysHeaps[ui32NextHeapID].ui32UsageFlags = PHYS_HEAP_USAGE_FW_SHARED;
 		ui32NextHeapID++;
 	}
-#endif
+	if (PVRSRV_VZ_MODE_IS(GUEST))
+	{
+		PVRSRV_ERROR eError;
+
+		if (gsDmaAlloc.sBusAddr.uiAddr)
+		{
+			OSFreeMem(pasPhysHeaps);
+			return PVRSRV_ERROR_ALREADY_EXISTS;
+		}
+
+		memset(&gsDmaAlloc, 0, sizeof(gsDmaAlloc));
+		gsDmaAlloc.ui64Size = RGX_FIRMWARE_RAW_HEAP_SIZE;
+		gsDmaAlloc.pvOSDevice = pvOSDevice;
+
+		eError = SysDmaAllocMem(&gsDmaAlloc);
+		if (eError)
+		{
+			OSFreeMem(pasPhysHeaps);
+			return eError;
+		}
+
+		eError = SysDmaRegisterForIoRemapping(&gsDmaAlloc);
+		if (eError)
+		{
+			SysDmaFreeMem(&gsDmaAlloc);
+			OSFreeMem(pasPhysHeaps);
+			gsDmaAlloc.sBusAddr.uiAddr = 0;
+			return eError;
+		}
+
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].eType = PHYS_HEAP_TYPE_DMA;
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].uConfig.sDMA.sStartAddr.uiAddr = gsDmaAlloc.sBusAddr.uiAddr;
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].uConfig.sDMA.sCardBase.uiAddr = gsDmaAlloc.sBusAddr.uiAddr;
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].uConfig.sDMA.uiSize = gsDmaAlloc.ui64Size;
+	}
+#endif /* defined(SUPPORT_FIXED_DEVICE_MEMORY) */	
 
 	*ppasPhysHeapsOut = pasPhysHeaps;
 	*puiPhysHeapCountOut = uiHeapCount;
@@ -231,6 +270,14 @@ static PVRSRV_ERROR PhysHeapsCreate(PHYS_HEAP_CONFIG **ppasPhysHeapsOut,
 
 static void PhysHeapsDestroy(PHYS_HEAP_CONFIG *pasPhysHeaps)
 {
+	if (PVRSRV_VZ_MODE_IS(GUEST))
+	{
+		if (gsDmaAlloc.sBusAddr.uiAddr) {
+			SysDmaDeregisterForIoRemapping(&gsDmaAlloc);
+			SysDmaFreeMem(&gsDmaAlloc);
+			gsDmaAlloc.sBusAddr.uiAddr = 0;
+		}
+	}
 	OSFreeMem(pasPhysHeaps);
 }
 
@@ -526,7 +573,7 @@ PVRSRV_ERROR SysDevInit(void *pvOSDevice, PVRSRV_DEVICE_CONFIG **ppsDevConfig)
 		goto ErrorFreeDevConfig;
 	}
 
-	eError = PhysHeapsCreate(&pasPhysHeaps, &uiPhysHeapCount);
+	eError = PhysHeapsCreate(&pasPhysHeaps, &uiPhysHeapCount, pvOSDevice);
 	if (eError)
 	{
 		goto ErrorFreeDevConfig;
-- 
2.34.1

