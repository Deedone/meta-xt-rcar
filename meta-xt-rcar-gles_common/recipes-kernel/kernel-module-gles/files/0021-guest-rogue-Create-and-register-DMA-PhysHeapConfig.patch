From 1075427885318b173e3edf9a7b9663beededa6f8 Mon Sep 17 00:00:00 2001
Message-Id: <1075427885318b173e3edf9a7b9663beededa6f8.1728389216.git.mykyta_poturai@epam.com>
In-Reply-To: <bc35a1559ba18018db00e017ef9359f091274151.1728389216.git.mykyta_poturai@epam.com>
References: <bc35a1559ba18018db00e017ef9359f091274151.1728389216.git.mykyta_poturai@epam.com>
From: Oleksandr Tyshchenko <oleksandr_tyshchenko@epam.com>
Date: Mon, 8 May 2023 19:20:20 +0300
Subject: [PATCH 21/22] guest/rogue: Create and register DMA PhysHeapConfig
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Implemented required functionality according to
“5.8.1. Hypervisor-assisted using dynamic firmware heap allocation”
section of “PowerVR Graphics DDK Services Virtualisation Porting Guide”.

Signed-off-by: Oleksandr Tyshchenko <oleksandr_tyshchenko@epam.com>
---
 services/system/rogue/rgx_rcar/sysconfig.c | 53 ++++++++++++++++++++--
 1 file changed, 50 insertions(+), 3 deletions(-)

diff --git a/services/system/rogue/rgx_rcar/sysconfig.c b/services/system/rogue/rgx_rcar/sysconfig.c
index 1c9c303..ab6a535 100644
--- a/services/system/rogue/rgx_rcar/sysconfig.c
+++ b/services/system/rogue/rgx_rcar/sysconfig.c
@@ -170,8 +170,11 @@ static PHYS_HEAP_FUNCTIONS gsPhysHeapFuncs =
 	xMAPhysHeapDevPAddrToCpuPAddr,
 };
 
+static DMA_ALLOC gsDmaAlloc;
+
 static PVRSRV_ERROR PhysHeapsCreate(PHYS_HEAP_CONFIG **ppasPhysHeapsOut,
-									IMG_UINT32 *puiPhysHeapCountOut)
+									IMG_UINT32 *puiPhysHeapCountOut,
+									void *pvOSDevice)
 {
 	/*
 	 * This function is called during device initialisation, which on Linux,
@@ -216,7 +219,42 @@ static PVRSRV_ERROR PhysHeapsCreate(PHYS_HEAP_CONFIG **ppasPhysHeapsOut,
 	pasPhysHeaps[PHYS_HEAP_IDX_FW].eType = PHYS_HEAP_TYPE_UMA;
 	pasPhysHeaps[PHYS_HEAP_IDX_FW].uConfig.sUMA.psMemFuncs = &gsPhysHeapFuncs;
 	pasPhysHeaps[PHYS_HEAP_IDX_FW].ui32UsageFlags = PHYS_HEAP_USAGE_FW_SHARED;
-#endif
+	if (PVRSRV_VZ_MODE_IS(GUEST))
+	{
+		PVRSRV_ERROR eError;
+
+		if (gsDmaAlloc.sBusAddr.uiAddr)
+		{
+			OSFreeMem(pasPhysHeaps);
+			return PVRSRV_ERROR_ALREADY_EXISTS;
+		}
+
+		memset(&gsDmaAlloc, 0, sizeof(gsDmaAlloc));
+		gsDmaAlloc.ui64Size = RGX_FIRMWARE_RAW_HEAP_SIZE;
+		gsDmaAlloc.pvOSDevice = pvOSDevice;
+
+		eError = SysDmaAllocMem(&gsDmaAlloc);
+		if (eError)
+		{
+			OSFreeMem(pasPhysHeaps);
+			return eError;
+		}
+
+		eError = SysDmaRegisterForIoRemapping(&gsDmaAlloc);
+		if (eError)
+		{
+			SysDmaFreeMem(&gsDmaAlloc);
+			OSFreeMem(pasPhysHeaps);
+			gsDmaAlloc.sBusAddr.uiAddr = 0;
+			return eError;
+		}
+
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].eType = PHYS_HEAP_TYPE_DMA;
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].sStartAddr.uiAddr = gsDmaAlloc.sBusAddr.uiAddr;
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].sCardBase.uiAddr = gsDmaAlloc.sBusAddr.uiAddr;
+		pasPhysHeaps[PHYS_HEAP_IDX_FW].uiSize = gsDmaAlloc.ui64Size;
+	}
+#endif /* defined(SUPPORT_FIXED_DEVICE_MEMORY) */	
 
 #if defined(SUPPORT_TRUSTED_DEVICE)
 	pasPhysHeaps[PHYS_HEAP_IDX_TDFWMEM].uConfig.sUMA.pszPDumpMemspaceName = "TDFWCODEMEM";
@@ -244,6 +282,15 @@ static PVRSRV_ERROR PhysHeapsCreate(PHYS_HEAP_CONFIG **ppasPhysHeapsOut,
 
 static void PhysHeapsDestroy(PHYS_HEAP_CONFIG *pasPhysHeaps)
 {
+	if (PVRSRV_VZ_MODE_IS(GUEST))
+	{
+		if (gsDmaAlloc.sBusAddr.uiAddr) {
+			SysDmaDeregisterForIoRemapping(&gsDmaAlloc);
+			SysDmaFreeMem(&gsDmaAlloc);
+			gsDmaAlloc.sBusAddr.uiAddr = 0;
+		}
+	}
+
 	OSFreeMem(pasPhysHeaps);
 }
 
@@ -534,7 +581,7 @@ PVRSRV_ERROR SysDevInit(void *pvOSDevice, PVRSRV_DEVICE_CONFIG **ppsDevConfig)
 		goto ErrorFreeDevConfig;
 	}
 
-	eError = PhysHeapsCreate(&pasPhysHeaps, &uiPhysHeapCount);
+	eError = PhysHeapsCreate(&pasPhysHeaps, &uiPhysHeapCount, pvOSDevice);
 	if (eError)
 	{
 		goto ErrorFreeDevConfig;
-- 
2.34.1

